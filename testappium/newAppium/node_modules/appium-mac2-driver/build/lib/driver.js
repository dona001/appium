"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Mac2Driver = void 0;
const lodash_1 = __importDefault(require("lodash"));
const driver_1 = require("appium/driver");
const wda_mac_1 = __importDefault(require("./wda-mac"));
const desired_caps_1 = require("./desired-caps");
const index_1 = __importDefault(require("./commands/index"));
const logger_1 = __importDefault(require("./logger"));
const method_map_1 = require("./method-map");
/** @type {import('@appium/types').RouteMatcher[]} */
const NO_PROXY = [
    ['GET', new RegExp('^/session/[^/]+/appium')],
    ['POST', new RegExp('^/session/[^/]+/appium')],
    ['POST', new RegExp('^/session/[^/]+/element/[^/]+/elements?$')],
    ['POST', new RegExp('^/session/[^/]+/elements?$')],
    ['POST', new RegExp('^/session/[^/]+/execute')],
    ['POST', new RegExp('^/session/[^/]+/execute/sync')],
    ['GET', new RegExp('^/session/[^/]+/timeouts$')],
    ['POST', new RegExp('^/session/[^/]+/timeouts$')],
];
class Mac2Driver extends driver_1.BaseDriver {
    constructor(opts = {}) {
        // @ts-ignore TODO: Make opts typed
        super(opts);
        this.desiredCapConstraints = desired_caps_1.desiredCapConstraints;
        this.locatorStrategies = [
            'id',
            'name',
            'accessibility id',
            'xpath',
            'class name',
            '-ios predicate string',
            'predicate string',
            '-ios class chain',
            'class chain',
        ];
        this.resetState();
        this.settings = new driver_1.DeviceSettings({}, this.onSettingsUpdate.bind(this));
        for (const [cmd, fn] of lodash_1.default.toPairs(index_1.default)) {
            Mac2Driver.prototype[cmd] = fn;
        }
    }
    async onSettingsUpdate(key, value) {
        return await this.wda?.proxy?.command('/appium/settings', 'POST', {
            settings: { [key]: value }
        });
    }
    resetState() {
        this.wda = null;
        this.proxyReqRes = null;
        this.isProxyActive = false;
        this._screenRecorder = null;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    proxyActive(sessionId) {
        return this.isProxyActive;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getProxyAvoidList(sessionId) {
        return NO_PROXY;
    }
    canProxy() {
        return true;
    }
    async proxyCommand(url, method, body = null) {
        return await this.wda?.proxy?.command(url, method, body);
    }
    // @ts-ignore We know WDA response should be ok
    async getStatus() {
        return await this.wda?.proxy?.command('/status', 'GET');
    }
    // @ts-ignore TODO: make args typed
    async createSession(...args) {
        // @ts-ignore TODO: make args typed
        const [sessionId, caps] = await super.createSession(...args);
        this.wda = wda_mac_1.default;
        try {
            if (caps.prerun) {
                if (!lodash_1.default.isString(caps.prerun.command) && !lodash_1.default.isString(caps.prerun.script)) {
                    throw new Error(`'prerun' capability value must either contain ` +
                        `'script' or 'command' entry of string type`);
                }
                logger_1.default.info('Executing prerun AppleScript');
                const output = await this.macosExecAppleScript(caps.prerun);
                if (lodash_1.default.trim(output)) {
                    logger_1.default.info(`Prerun script output: ${output}`);
                }
            }
            await this.wda.startSession(caps);
        }
        catch (e) {
            await this.deleteSession();
            throw e;
        }
        this.proxyReqRes = this.wda?.proxy?.proxyReqRes.bind(this.wda.proxy);
        this.isProxyActive = true;
        return [sessionId, caps];
    }
    async deleteSession() {
        await this._screenRecorder?.stop(true);
        await this.wda?.stopSession();
        if (this.opts.postrun) {
            if (!lodash_1.default.isString(this.opts.postrun.command) && !lodash_1.default.isString(this.opts.postrun.script)) {
                logger_1.default.error(`'postrun' capability value must either contain ` +
                    `'script' or 'command' entry of string type`);
            }
            else {
                logger_1.default.info('Executing postrun AppleScript');
                try {
                    const output = await this.macosExecAppleScript(this.opts.postrun);
                    if (lodash_1.default.trim(output)) {
                        logger_1.default.info(`Postrun script output: ${output}`);
                    }
                }
                catch (e) {
                    logger_1.default.error(e.message);
                }
            }
        }
        this.resetState();
        await super.deleteSession();
    }
}
exports.Mac2Driver = Mac2Driver;
Mac2Driver.newMethodMap = method_map_1.newMethodMap;
exports.default = Mac2Driver;
//# sourceMappingURL=driver.js.map