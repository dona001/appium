"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.registerProxyMiddlware = exports.removeProxyHandler = exports.addProxyHandler = void 0;
const https_proxy_agent_1 = require("https-proxy-agent");
const http_proxy_agent_1 = require("http-proxy-agent");
const http_proxy_middleware_1 = require("http-proxy-middleware");
const device_service_1 = require("./data-service/device-service");
const axios_1 = __importDefault(require("axios"));
const logger_1 = __importDefault(require("./logger"));
const remoteProxyMap = new Map();
const remoteHostMap = new Map();
const deviceSessionMap = new Map();
function getProxyServer() {
    return process.env.HTTP_PROXY || process.env.HTTPS_PROXY;
}
function addProxyHandler(sessionId, remoteHost) {
    const proxyServer = getProxyServer();
    const targetBasePath = new URL(remoteHost).pathname;
    const config = {
        target: new URL(remoteHost).origin,
        changeOrigin: true,
        pathRewrite: (path, req) => {
            const newPath = `${targetBasePath}/${path}`;
            return newPath;
        },
        on: {
            proxyReq: proxyRequestInterceptor,
            proxyRes: (proxyRes, req, res) => {
                // log.debug(`proxyRes host: ${req.headers.host} method: ${req.method}  path: ${req.url}`);
            },
            error: (err, req, res) => {
                logger_1.default.error('proxy handler error: ', err.message, ' data: ', err.response.data);
            },
        },
    };
    if (proxyServer) {
        //log.info(`Added proxy to createProxyMiddleware: ${JSON.stringify(proxyServer)}`);
        config.agent = new https_proxy_agent_1.HttpsProxyAgent(proxyServer);
    }
    logger_1.default.info(`Creating remote proxy for session ${sessionId} to ${remoteHost}`);
    remoteProxyMap.set(sessionId, (0, http_proxy_middleware_1.createProxyMiddleware)(config));
    remoteHostMap.set(sessionId, remoteHost);
}
exports.addProxyHandler = addProxyHandler;
function removeProxyHandler(sessionId) {
    remoteProxyMap.delete(sessionId);
}
exports.removeProxyHandler = removeProxyHandler;
function proxyRequestInterceptor(proxyReq, req, res) {
    if (!new RegExp(/post|put|patch/g).test(req.method.toLowerCase())) {
        logger_1.default.debug(`ðŸ“± Skipping request for session ${JSON.stringify(req.method)}`);
        return;
    }
    // log.debug(`ðŸ“± Intercepting request ${req.method} ${req.url} ${JSON.stringify(req.body)}`);
    const contentType = proxyReq.getHeader('Content-Type');
    const writeBody = (bodyData) => {
        proxyReq.setHeader('Content-Length', Buffer.byteLength(bodyData));
        proxyReq.write(bodyData);
        proxyReq.end();
    };
    if (contentType && contentType.includes('application/json')) {
        writeBody(JSON.stringify(req.body || {}));
    }
}
function getSessionIdFromUr(url) {
    const SESSION_ID_PATTERN = /\/session\/([^/]+)/;
    const match = SESSION_ID_PATTERN.exec(url);
    if (match) {
        return match[1];
    }
    return null;
}
function handler(req, res, next) {
    return __awaiter(this, void 0, void 0, function* () {
        const proxyServer = getProxyServer();
        const sessionId = getSessionIdFromUr(req.url);
        if (!sessionId) {
            return next();
        }
        yield (0, device_service_1.updateCmdExecutedTime)(sessionId);
        if (remoteProxyMap.has(sessionId)) {
            // update
            if (proxyServer) {
                const response = yield (0, axios_1.default)({
                    method: req.method,
                    url: new URL(req.path, new URL(remoteHostMap.get(sessionId)).origin).toString(),
                    data: req.body,
                    params: req.query,
                    validateStatus: () => true,
                    httpsAgent: new https_proxy_agent_1.HttpsProxyAgent(proxyServer),
                    httpAgent: new http_proxy_agent_1.HttpProxyAgent(proxyServer),
                    proxy: false,
                });
                res.status(response.status).json(response.data);
            }
            else {
                remoteProxyMap.get(sessionId)(req, res, next);
            }
            if (req.method === 'DELETE') {
                logger_1.default.info(`ðŸ“± Unblocking the device that is blocked for session ${sessionId} in remote machine`);
                (0, device_service_1.unblockDeviceMatchingFilter)({ session_id: sessionId });
                removeProxyHandler(sessionId);
            }
        }
        else {
            return next();
        }
    });
}
function registerProxyMiddlware(expressApp) {
    logger_1.default.info('Registering proxy middleware');
    const index = expressApp._router.stack.findIndex((s) => s.route);
    expressApp.use('/', handler);
    expressApp._router.stack.splice(index, 0, expressApp._router.stack.pop());
}
exports.registerProxyMiddlware = registerProxyMiddlware;
