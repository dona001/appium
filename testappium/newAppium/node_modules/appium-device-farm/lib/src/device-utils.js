"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupCronCleanPendingSessions = exports.cleanPendingSessions = exports.setupCronUpdateDeviceList = exports.setupCronReleaseBlockedDevices = exports.releaseBlockedDevices = exports.unblockCandidateDevices = exports.removeStaleDevices = exports.setupCronCheckStaleDevices = exports.refreshSimulatorState = exports.updateDeviceList = exports.getBusyDevicesCount = exports.getDeviceFiltersFromCapability = exports.setUtilizationTime = exports.getUtilizationTime = exports.initializeStorage = exports.updateCapabilityForDevice = exports.allocateDeviceForSession = exports.isDeviceConfigPathAbsolute = exports.isAndroidAndIOS = exports.isIOS = exports.deviceType = exports.isAndroid = exports.getDeviceTypeFromApp = void 0;
/* eslint-disable no-prototype-builtins */
const helpers_1 = require("./helpers");
const CapabilityManager_1 = require("./CapabilityManager");
const async_wait_until_1 = __importDefault(require("async-wait-until"));
const typedi_1 = require("typedi");
const device_managers_1 = require("./device-managers");
const device_service_1 = require("./data-service/device-service");
const logger_1 = __importDefault(require("./logger"));
const Platform_1 = __importDefault(require("./enums/Platform"));
const lodash_1 = __importDefault(require("lodash"));
const fs_1 = __importDefault(require("fs"));
const CapabilityManager_2 = __importDefault(require("./device-managers/cloud/CapabilityManager"));
const IOSDeviceManager_1 = __importDefault(require("./device-managers/IOSDeviceManager"));
const NodeDevices_1 = __importDefault(require("./device-managers/NodeDevices"));
const db_1 = require("./data-service/db");
const customCapability = {
    deviceTimeOut: 'appium:deviceAvailabilityTimeout',
    deviceQueryInterval: 'appium:deviceRetryInterval',
    iphoneOnly: 'appium:iPhoneOnly',
    ipadOnly: 'appium:iPadOnly',
    udids: 'appium:udids',
    minSDK: 'appium:minSDK',
    maxSDK: 'appium:maxSDK',
};
let timer;
let cronTimerToReleaseBlockedDevices;
let cronTimerToUpdateDevices;
let cronTimerToCleanPendingSessions;
const getDeviceTypeFromApp = (app) => {
    /* If the test is targeting safarim, then app capability will be empty */
    if (!app) {
        return;
    }
    return app.endsWith('.app') || app.endsWith('.zip') ? 'simulator' : 'real';
};
exports.getDeviceTypeFromApp = getDeviceTypeFromApp;
function isAndroid(cliArgs) {
    return cliArgs.Platform.toLowerCase() === Platform_1.default.ANDROID;
}
exports.isAndroid = isAndroid;
function deviceType(pluginArgs, device) {
    const iosDeviceType = pluginArgs.iosDeviceType;
    return iosDeviceType === device || iosDeviceType === 'both';
}
exports.deviceType = deviceType;
function isIOS(pluginArgs) {
    return (0, helpers_1.isMac)() && pluginArgs.platform.toLowerCase() === Platform_1.default.IOS;
}
exports.isIOS = isIOS;
function isAndroidAndIOS(pluginArgs) {
    return (0, helpers_1.isMac)() && pluginArgs.platform.toLowerCase() === Platform_1.default.BOTH;
}
exports.isAndroidAndIOS = isAndroidAndIOS;
function isDeviceConfigPathAbsolute(path) {
    if ((0, helpers_1.checkIfPathIsAbsolute)(path)) {
        return true;
    }
    else {
        throw new Error(`Device Config Path ${path} should be absolute`);
    }
}
exports.isDeviceConfigPathAbsolute = isDeviceConfigPathAbsolute;
/**
 * For given capability, wait untill a free device is available from the database
 * and update the capability json with required device informations
 * @param capability
 * @returns
 */
function allocateDeviceForSession(capability, deviceTimeOutMs, deviceQueryIntervalMs, pluginArgs) {
    return __awaiter(this, void 0, void 0, function* () {
        const firstMatch = Object.assign({}, capability.firstMatch[0], capability.alwaysMatch);
        // log.debug(`firstMatch: ${JSON.stringify(firstMatch)}`);
        const filters = getDeviceFiltersFromCapability(firstMatch, pluginArgs);
        // log.debug(`Device allocation request for filter: ${JSON.stringify(filters)}`);
        const timeout = firstMatch[customCapability.deviceTimeOut] || deviceTimeOutMs;
        const intervalBetweenAttempts = firstMatch[customCapability.deviceQueryInterval] || deviceQueryIntervalMs;
        try {
            yield (0, async_wait_until_1.default)(() => __awaiter(this, void 0, void 0, function* () {
                const maxSessions = getDeviceManager().getMaxSessionCount();
                const busyDevicesCount = yield getBusyDevicesCount();
                logger_1.default.debug(`Max session count: ${maxSessions}, Busy device count: ${busyDevicesCount}`);
                if (maxSessions !== undefined && busyDevicesCount === maxSessions) {
                    logger_1.default.info(`Waiting for session available, already at max session count of: ${maxSessions}`);
                    return false;
                }
                else
                    logger_1.default.info(`Waiting for free device. Filter: ${JSON.stringify(filters)}}`);
                return (yield (0, device_service_1.getDevice)(filters)) != undefined;
            }), { timeout, intervalBetweenAttempts });
        }
        catch (err) {
            throw new Error(`No device found for filters: ${JSON.stringify(filters)}`);
        }
        const device = yield (0, device_service_1.getDevice)(filters);
        if (device != undefined) {
            // log.info(`ðŸ“± Device found: ${JSON.stringify(device)}`);
            yield (0, device_service_1.blockDevice)(device.udid, device.host);
            logger_1.default.info(`ðŸ“± Blocking device ${device.udid} at host ${device.host} for new session`);
            // FIXME: convert this into a return value
            yield updateCapabilityForDevice(capability, device);
            // update newCommandTimeout for the device.
            // This is required so it won't get unblocked by prematurely.
            let newCommandTimeout = firstMatch['appium:newCommandTimeout'];
            if (!newCommandTimeout) {
                newCommandTimeout = pluginArgs.newCommandTimeoutSec;
            }
            (0, device_service_1.updatedAllocatedDevice)(device, { newCommandTimeout });
            return device;
        }
        else {
            throw new Error(`No device found for filters: ${JSON.stringify(filters)}`);
        }
    });
}
exports.allocateDeviceForSession = allocateDeviceForSession;
/**
 * Adjust the capability for the device
 * @param capability
 * @param device
 * @returns
 */
function updateCapabilityForDevice(capability, device) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!device.hasOwnProperty('cloud')) {
            if (device.platform.toLowerCase() == Platform_1.default.ANDROID) {
                yield (0, CapabilityManager_1.androidCapabilities)(capability, device);
            }
            else {
                yield (0, CapabilityManager_1.iOSCapabilities)(capability, device);
            }
        }
        else {
            logger_1.default.info('Updating cloud capability for Device');
            return new CapabilityManager_2.default(capability, device).getCapability();
        }
    });
}
exports.updateCapabilityForDevice = updateCapabilityForDevice;
/**
 * Sets up node-persist storage in local cache
 * @returns storage
 */
function initializeStorage() {
    return __awaiter(this, void 0, void 0, function* () {
        logger_1.default.info('Initializing storage');
        const basePath = (0, helpers_1.cachePath)('storage');
        yield fs_1.default.promises.mkdir(basePath, { recursive: true });
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        const storage = require('node-persist');
        const localStorage = storage.create({ dir: basePath });
        yield localStorage.init();
        typedi_1.Container.set('LocalStorage', localStorage);
    });
}
exports.initializeStorage = initializeStorage;
function getStorage() {
    try {
        typedi_1.Container.get('LocalStorage');
    }
    catch (err) {
        logger_1.default.error(`Failed to get LocalStorage: Error ${err}`);
        initializeStorage();
    }
    return typedi_1.Container.get('LocalStorage');
}
/**
 * Gets utlization time for a device from storage
 * Returns 0 if the device has not been used an thus utilization time has not been saved
 * @param udid
 * @returns number
 */
function getUtilizationTime(udid) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const value = yield getStorage().getItem(udid);
            if (value !== undefined && value && !isNaN(value)) {
                return value;
            }
            else {
                //log.error(`Custom Exception: Utilizaiton time in cache is corrupted. Value = '${value}'.`);
            }
        }
        catch (err) {
            logger_1.default.error(`Failed to fetch Utilization Time \n ${err}`);
        }
        return 0;
    });
}
exports.getUtilizationTime = getUtilizationTime;
/**
 * Sets utilization time for a device to storage
 * @param udid
 * @param utilizationTime
 */
function setUtilizationTime(udid, utilizationTime) {
    return __awaiter(this, void 0, void 0, function* () {
        yield getStorage().setItem(udid, utilizationTime);
    });
}
exports.setUtilizationTime = setUtilizationTime;
/**
 * Method to get the device filters from the custom session capability
 * This filter will be used as in the query to find the free device from the databse
 * @param capability
 * @returns IDeviceFilterOptions
 */
function getDeviceFiltersFromCapability(capability, pluginArgs) {
    var _a;
    const platform = capability['platformName'].toLowerCase();
    const udids = capability[customCapability.udids]
        ? capability[customCapability.udids].split(',').map(lodash_1.default.trim)
        : (_a = process.env.UDIDS) === null || _a === void 0 ? void 0 : _a.split(',').map(lodash_1.default.trim);
    /* Based on the app file extension, we will decide whether to run the
     * test on real device or simulator.
     *
     * Applicaple only for ios.
     */
    const deviceType = platform == Platform_1.default.IOS
        ? (0, exports.getDeviceTypeFromApp)(capability['appium:app'])
        : undefined;
    if ((deviceType === null || deviceType === void 0 ? void 0 : deviceType.startsWith('sim')) && pluginArgs.iosDeviceType === 'real') {
        throw new Error('iosDeviceType value is set to "real" but app provided is not suitable for real device.');
    }
    if ((deviceType === null || deviceType === void 0 ? void 0 : deviceType.startsWith('real')) && pluginArgs.iosDeviceType == 'simulated') {
        throw new Error('iosDeviceType value is set to "simulated" but app provided is not suitable for simulator device.');
    }
    let name = undefined;
    if (capability[customCapability.ipadOnly]) {
        name = 'iPad';
    }
    else if (capability[customCapability.iphoneOnly]) {
        name = 'iPhone';
    }
    let caps = {
        platform,
        platformVersion: capability['appium:platformVersion']
            ? capability['appium:platformVersion']
            : undefined,
        name,
        deviceType,
        udid: (udids === null || udids === void 0 ? void 0 : udids.length) ? udids[0] : capability['appium:udid'],
        busy: false,
        userBlocked: false,
        minSDK: capability[customCapability.minSDK] ? capability[customCapability.minSDK] : undefined,
        maxSDK: capability[customCapability.maxSDK] ? capability[customCapability.maxSDK] : undefined,
    };
    if (name !== undefined) {
        caps = Object.assign(Object.assign({}, caps), { name });
    }
    return caps;
}
exports.getDeviceFiltersFromCapability = getDeviceFiltersFromCapability;
/**
 * Helper methods to manage devices
 */
function getDeviceManager() {
    return typedi_1.Container.get(device_managers_1.DeviceFarmManager);
}
function getBusyDevicesCount() {
    return __awaiter(this, void 0, void 0, function* () {
        const allDevices = yield (0, device_service_1.getAllDevices)();
        return allDevices.filter((device) => {
            return device.busy;
        }).length;
    });
}
exports.getBusyDevicesCount = getBusyDevicesCount;
function updateDeviceList(host, hubArgument) {
    return __awaiter(this, void 0, void 0, function* () {
        const devices = yield getDeviceManager().getDevices(yield (0, device_service_1.getAllDevices)());
        if (devices.length === 0) {
            logger_1.default.warn('No devices found');
            return [];
        }
        // log.debug(`Updating device list with ${JSON.stringify(devices)} devices`);
        // first thing first. Update device list in local list
        yield (0, device_service_1.addNewDevice)(devices, host);
        if (hubArgument) {
            if (yield (0, helpers_1.isDeviceFarmRunning)(hubArgument)) {
                const nodeDevices = new NodeDevices_1.default(hubArgument);
                try {
                    yield nodeDevices.postDevicesToHub(devices, 'add');
                }
                catch (error) {
                    logger_1.default.error(`Cannot send device list update. Reason: ${error}`);
                }
            }
            else {
                logger_1.default.warn(`Not sending device update since hub ${hubArgument} is not running`);
            }
        }
        return devices;
    });
}
exports.updateDeviceList = updateDeviceList;
function refreshSimulatorState(pluginArgs, hostPort) {
    return __awaiter(this, void 0, void 0, function* () {
        if (timer) {
            clearInterval(timer);
        }
        timer = setInterval(() => __awaiter(this, void 0, void 0, function* () {
            const simulators = yield new IOSDeviceManager_1.default(pluginArgs, hostPort).getSimulators();
            yield (0, device_service_1.setSimulatorState)(simulators);
        }), 10000);
    });
}
exports.refreshSimulatorState = refreshSimulatorState;
function setupCronCheckStaleDevices(intervalMs, currentHost) {
    return __awaiter(this, void 0, void 0, function* () {
        setInterval(() => __awaiter(this, void 0, void 0, function* () {
            yield removeStaleDevices(currentHost);
        }), intervalMs);
    });
}
exports.setupCronCheckStaleDevices = setupCronCheckStaleDevices;
/**
 * Remove devices where the host is not alive nor defined.
 * @param currentHost current host ip address
 */
function removeStaleDevices(currentHost) {
    return __awaiter(this, void 0, void 0, function* () {
        const allDevices = yield (0, device_service_1.getAllDevices)();
        const nodeDevices = allDevices.filter((device) => {
            // devices that's not from this node ip address
            return device.host !== undefined && !device.host.includes(currentHost);
        });
        const devicesWithNoHost = nodeDevices.filter((device) => {
            return device.host === undefined;
        });
        const nodeHosts = nodeDevices
            .filter((device) => !device.hasOwnProperty('cloud'))
            .map((device) => device.host);
        const cloudHosts = nodeDevices
            .filter((device) => device.hasOwnProperty('cloud'))
            .map((device) => device.host);
        const aliveHosts = (yield Promise.allSettled(nodeHosts.map((host) => __awaiter(this, void 0, void 0, function* () {
            return {
                host: host,
                alive: yield (0, helpers_1.isDeviceFarmRunning)(host),
            };
        }))));
        const aliveCloudHosts = (yield Promise.allSettled(cloudHosts.map((host) => __awaiter(this, void 0, void 0, function* () {
            return {
                host: host,
                alive: yield (0, helpers_1.isAppiumRunningAt)(host),
            };
        }))));
        // summarize alive hosts
        const allAliveHosts = [...aliveHosts, ...aliveCloudHosts]
            .filter((item) => item.status === 'fulfilled')
            .map((item) => item.value.host);
        // stale devices are devices that's not alive
        const staleDevices = nodeDevices.filter((device) => !allAliveHosts.includes(device.host));
        (0, device_service_1.removeDevice)(staleDevices.map((device) => ({ udid: device.udid, host: device.host })));
        if (staleDevices.length > 0) {
            logger_1.default.debug(`Removing device with udid(s): ${staleDevices
                .map((device) => device.udid)
                .join(', ')} because the node is not alive`);
        }
        // remove devices with no host
        (0, device_service_1.removeDevice)(devicesWithNoHost.map((device) => ({ udid: device.udid, host: device.host })));
        if (devicesWithNoHost.length > 0) {
            logger_1.default.debug(`Removing device with udid(s): ${devicesWithNoHost
                .map((device) => device.udid)
                .join(', ')} because the device has no host`);
        }
    });
}
exports.removeStaleDevices = removeStaleDevices;
function unblockCandidateDevices() {
    return __awaiter(this, void 0, void 0, function* () {
        const allDevices = yield (0, device_service_1.getAllDevices)();
        const busyDevices = allDevices.filter((device) => {
            const isCandidate = device.busy && !device.userBlocked && device.lastCmdExecutedAt != undefined;
            // log.debug(`Checking if device ${device.udid} from ${device.host} is a candidate to be released: ${isCandidate}`);
            return isCandidate;
        });
        return busyDevices;
    });
}
exports.unblockCandidateDevices = unblockCandidateDevices;
function releaseBlockedDevices(newCommandTimeout) {
    return __awaiter(this, void 0, void 0, function* () {
        const busyDevices = yield unblockCandidateDevices();
        logger_1.default.debug(`Found ${busyDevices.length} device candidates to be released`);
        busyDevices.forEach(function (device) {
            // need to keep this to make typescript happy. good thing tho.
            if (device.lastCmdExecutedAt == undefined) {
                return;
            }
            const currentEpoch = new Date().getTime();
            const timeoutSeconds = device.newCommandTimeout != undefined ? device.newCommandTimeout : newCommandTimeout;
            const timeSinceLastCmdExecuted = (currentEpoch - device.lastCmdExecutedAt) / 1000;
            if (timeSinceLastCmdExecuted > timeoutSeconds) {
                // unblock regardless of whether the device has session or not
                logger_1.default.info(`Unblocking device ${device.udid} at host ${device.host} because it has been idle for ${timeSinceLastCmdExecuted} seconds`);
                (0, device_service_1.unblockDevice)(device.udid, device.host);
            }
        });
    });
}
exports.releaseBlockedDevices = releaseBlockedDevices;
function setupCronReleaseBlockedDevices(intervalMs, newCommandTimeoutSec) {
    return __awaiter(this, void 0, void 0, function* () {
        if (cronTimerToReleaseBlockedDevices) {
            clearInterval(cronTimerToReleaseBlockedDevices);
        }
        yield releaseBlockedDevices(newCommandTimeoutSec);
        cronTimerToReleaseBlockedDevices = setInterval(() => __awaiter(this, void 0, void 0, function* () {
            yield releaseBlockedDevices(newCommandTimeoutSec);
        }), intervalMs);
    });
}
exports.setupCronReleaseBlockedDevices = setupCronReleaseBlockedDevices;
function setupCronUpdateDeviceList(host, hubArgument, intervalMs) {
    return __awaiter(this, void 0, void 0, function* () {
        if (cronTimerToUpdateDevices) {
            clearInterval(cronTimerToUpdateDevices);
        }
        logger_1.default.info(`This node will send device list update to the hub (${hubArgument}) every ${intervalMs} ms`);
        cronTimerToUpdateDevices = setInterval(() => __awaiter(this, void 0, void 0, function* () {
            yield updateDeviceList(host, hubArgument);
        }), intervalMs);
    });
}
exports.setupCronUpdateDeviceList = setupCronUpdateDeviceList;
function cleanPendingSessions(timeoutMs) {
    var _a, e_1, _b, _c;
    return __awaiter(this, void 0, void 0, function* () {
        const pendingSessions = (yield db_1.ADTDatabase.PendingSessionsModel).chain().find().data();
        const currentEpoch = new Date().getTime();
        const timedOutSessions = pendingSessions.filter((session) => {
            const timeSinceSessionCreated = currentEpoch - session.createdAt;
            logger_1.default.debug(`Session queue ID:${session.capability_id} has been pending for ${timeSinceSessionCreated} ms`);
            return timeSinceSessionCreated > timeoutMs;
        });
        if (timedOutSessions.length === 0) {
            logger_1.default.debug(`No pending sessions to clean`);
        }
        else {
            logger_1.default.debug(`Found ${timedOutSessions.length} pending sessions to clean`);
        }
        try {
            for (var _d = true, timedOutSessions_1 = __asyncValues(timedOutSessions), timedOutSessions_1_1; timedOutSessions_1_1 = yield timedOutSessions_1.next(), _a = timedOutSessions_1_1.done, !_a; _d = true) {
                _c = timedOutSessions_1_1.value;
                _d = false;
                const session = _c;
                logger_1.default.debug(`Removing pending session ${session.capability_id} because it has timed out`);
                (yield db_1.ADTDatabase.PendingSessionsModel).remove(session);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (!_d && !_a && (_b = timedOutSessions_1.return)) yield _b.call(timedOutSessions_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    });
}
exports.cleanPendingSessions = cleanPendingSessions;
function setupCronCleanPendingSessions(intervalMs, timeoutMs) {
    return __awaiter(this, void 0, void 0, function* () {
        logger_1.default.info(`Hub will clean pending sessions every ${intervalMs} ms with pending session timeout: ${timeoutMs} ms`);
        if (cronTimerToCleanPendingSessions) {
            clearInterval(cronTimerToCleanPendingSessions);
        }
        cronTimerToCleanPendingSessions = setInterval(() => __awaiter(this, void 0, void 0, function* () {
            logger_1.default.debug(`Cleaning pending sessions...`);
            yield cleanPendingSessions(timeoutMs);
        }), intervalMs);
    });
}
exports.setupCronCleanPendingSessions = setupCronCleanPendingSessions;
