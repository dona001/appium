"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const helpers_1 = require("../helpers");
const appium_adb_1 = require("appium-adb");
const logger_1 = __importDefault(require("../logger"));
const lodash_1 = __importDefault(require("lodash"));
const support_1 = require("@appium/support");
const ChromeDriverManager_1 = __importDefault(require("./ChromeDriverManager"));
const typedi_1 = require("typedi");
const device_utils_1 = require("../device-utils");
const adbkit_1 = __importDefault(require("@devicefarmer/adbkit"));
const node_abort_controller_1 = require("node-abort-controller");
const async_wait_until_1 = __importDefault(require("async-wait-until"));
const NodeDevices_1 = __importDefault(require("./NodeDevices"));
const device_service_1 = require("../data-service/device-service");
const Devices_1 = __importDefault(require("./cloud/Devices"));
class AndroidDeviceManager {
    constructor(pluginArgs, hostPort) {
        this.pluginArgs = pluginArgs;
        this.hostPort = hostPort;
        this.adbAvailable = true;
        this.abortControl = new Map();
        this.getDeviceName = (adbInstance, udid) => __awaiter(this, void 0, void 0, function* () {
            let deviceName = yield this.getDeviceProperty(yield adbInstance, udid, 'ro.product.name');
            if (!deviceName || (deviceName && deviceName.trim() === '')) {
                // If the device name is null or empty, try to get it from the Bluetooth manager.
                deviceName = yield (yield adbInstance).adbExec([
                    '-s',
                    udid,
                    'shell',
                    'dumpsys',
                    'bluetooth_manager',
                    '|',
                    'grep',
                    'name:',
                    '|',
                    'cut',
                    '-c9-',
                ]);
            }
            return deviceName;
        });
    }
    initiateAbortControl(deviceUdid) {
        const control = new node_abort_controller_1.AbortController();
        this.abortControl.set(deviceUdid, control);
        return control;
    }
    abort(deviceUdid) {
        var _a;
        (_a = this.abortControl.get(deviceUdid)) === null || _a === void 0 ? void 0 : _a.abort();
    }
    cancelAbort(deviceUdid) {
        if (this.abortControl.has(deviceUdid)) {
            this.abortControl.delete(deviceUdid);
        }
    }
    getDevices(deviceTypes, existingDeviceDetails) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.adbAvailable) {
                logger_1.default.info('adb is not available. So, returning empty list');
                return [];
            }
            let devices = [];
            try {
                if (this.pluginArgs.cloud != undefined) {
                    const cloud = new Devices_1.default(this.pluginArgs.cloud, devices, 'android');
                    return yield cloud.getDevices();
                }
                else {
                    devices = yield this.fetchAndroidDevices(existingDeviceDetails, this.pluginArgs);
                    logger_1.default.info(`Found ${devices.length} android devices`);
                }
                if (deviceTypes.androidDeviceType === 'real') {
                    return devices.filter((device) => {
                        return device.deviceType === 'real';
                    });
                }
                else if (deviceTypes.androidDeviceType === 'simulated') {
                    return devices.filter((device) => {
                        return device.deviceType === 'emulator';
                    });
                    // return both real and simulated (emulated) devices
                }
                else {
                    return devices;
                }
            }
            catch (e) {
                logger_1.default.error(`Error while getting android devices. Error: ${e}`);
            }
            return [];
        });
    }
    fetchAndroidDevices(existingDeviceDetails, pluginArgs) {
        var _a, e_1, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            yield this.requireSdkRoot();
            let availableDevices = [];
            const connectedDevices = yield this.getConnectedDevices(pluginArgs);
            //log.debug(`fetchAndroidDevices: ${JSON.stringify(connectedDevices)}`);
            for (const [adbInstance, devices] of connectedDevices) {
                logger_1.default.debug(`fetchAndroidDevices from host: ${adbInstance.adbHost}. Found ${devices.length} android devices`);
                try {
                    for (var _d = true, devices_1 = (e_1 = void 0, __asyncValues(devices)), devices_1_1; devices_1_1 = yield devices_1.next(), _a = devices_1_1.done, !_a; _d = true) {
                        _c = devices_1_1.value;
                        _d = false;
                        const device = _c;
                        // log.info(`Checking device ${device.udid}`);
                        device.adbRemoteHost =
                            adbInstance.adbRemoteHost === null
                                ? this.pluginArgs.bindHostOrIp
                                : adbInstance.adbRemoteHost;
                        if (!availableDevices.find((existingDevice) => existingDevice.udid === device.udid &&
                            existingDevice.adbRemoteHost === device.adbRemoteHost)) {
                            const existingDevice = existingDeviceDetails.find((dev) => dev.udid === device.udid && dev.host.includes(this.pluginArgs.bindHostOrIp));
                            if (existingDevice) {
                                logger_1.default.info(`Android Device details for ${device.udid} already available`);
                                availableDevices.push(Object.assign(Object.assign({}, existingDevice), { busy: false }));
                            }
                            else {
                                logger_1.default.info(`Android Device details for ${device.udid} not available. So querying now.`);
                                // device may have changed the status since the last time we queried
                                // we want to avoid device with offline or unauthorized status
                                if (device.state === 'device') {
                                    const deviceInfo = yield this.deviceInfo(device, adbInstance, this.pluginArgs, this.hostPort);
                                    if (!deviceInfo) {
                                        logger_1.default.info(`Cannot get device info for ${device.udid}. Skipping`);
                                    }
                                    else {
                                        availableDevices.push(deviceInfo);
                                    }
                                }
                                else {
                                    logger_1.default.info(`Device ${device.udid} is not in "device" state. So, ignoring.`);
                                }
                            }
                        }
                        else {
                            // log.info(`Device ${device.udid} is already in list. So, ignoring.`);
                            // log.debug(`Current list of devices: ${JSON.stringify(availableDevices)}`);
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (!_d && !_a && (_b = devices_1.return)) yield _b.call(devices_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            return availableDevices;
        });
    }
    deviceInfo(device, adbInstance, pluginArgs, hostPort) {
        return __awaiter(this, void 0, void 0, function* () {
            const systemPort = yield (0, helpers_1.getFreePort)();
            const totalUtilizationTimeMilliSec = yield (0, device_utils_1.getUtilizationTime)(device.udid);
            let deviceInfo;
            try {
                deviceInfo = yield Promise.all([
                    this.getDeviceVersion(adbInstance, device.udid),
                    this.isRealDevice(adbInstance, device.udid),
                    this.getDeviceName(adbInstance, device.udid),
                    this.getChromeVersion(adbInstance, device.udid, pluginArgs),
                ]);
            }
            catch (error) {
                logger_1.default.info(`Error while getting device info for ${device.udid}. Error: ${error}`);
                return undefined;
            }
            const [sdk, realDevice, name, chromeDriverPath] = deviceInfo;
            // if cliArgs contains skipChromeDownload, then chromeDriverPath will be undefined
            if (!pluginArgs.skipChromeDownload && chromeDriverPath === undefined) {
                logger_1.default.info(`Cannot get chromeDriverPath for ${device.udid}. Skipping`);
                return undefined;
            }
            // Except for chromeDriverPath, all other info is mandatory
            if (lodash_1.default.isNil(sdk) || lodash_1.default.isNil(realDevice) || lodash_1.default.isNil(name)) {
                logger_1.default.info(`Cannot get device info for ${device.udid}. Skipping`);
                return undefined;
            }
            let host;
            if (adbInstance.adbHost != null) {
                host = `http://${adbInstance.adbHost}:${adbInstance.adbPort}`;
            }
            else if (pluginArgs.remoteMachineProxyIP !== undefined) {
                host = `${pluginArgs.remoteMachineProxyIP}`;
            }
            else {
                host = `http://${pluginArgs.bindHostOrIp}:${hostPort}`;
            }
            return {
                adbRemoteHost: adbInstance.adbHost,
                adbPort: adbInstance.adbPort,
                systemPort,
                sdk: sdk !== null && sdk !== void 0 ? sdk : 'unknown',
                realDevice,
                name: name !== null && name !== void 0 ? name : 'unknown',
                busy: false,
                state: device.state,
                udid: device.udid,
                platform: 'android',
                deviceType: realDevice ? 'real' : 'emulator',
                host,
                totalUtilizationTimeMilliSec: totalUtilizationTimeMilliSec,
                sessionStartTime: 0,
                chromeDriverPath,
                userBlocked: false,
            };
        });
    }
    getAdb() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (!this.adb) {
                    this.adb = yield appium_adb_1.ADB.createADB({});
                }
            }
            catch (e) {
                this.adbAvailable = false;
            }
            return this.adb;
        });
    }
    waitBootComplete(originalADB, udid) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, async_wait_until_1.default)(() => __awaiter(this, void 0, void 0, function* () {
                try {
                    const bootStatus = (yield this.getDeviceProperty(originalADB, udid, 'init.svc.bootanim'));
                    if (!lodash_1.default.isNil(bootStatus) && !lodash_1.default.isEmpty(bootStatus) && bootStatus == 'stopped') {
                        console.log('Boot Completed!', udid);
                        return true;
                    }
                }
                catch (err) {
                    return false;
                }
            }), {
                intervalBetweenAttempts: 2000,
                timeout: 60 * 1000,
            });
        });
    }
    getConnectedDevices(pluginArgs) {
        return __awaiter(this, void 0, void 0, function* () {
            const deviceList = new Map();
            const originalADB = yield this.getAdb();
            deviceList.set(originalADB, yield originalADB.getConnectedDevices());
            const client = adbkit_1.default.createClient();
            const originalADBTracking = this.createLocalAdbTracker(client, originalADB);
            yield originalADBTracking();
            const adbRemote = pluginArgs.adbRemote;
            if (adbRemote !== undefined && adbRemote.length > 0) {
                yield (0, helpers_1.asyncForEach)(adbRemote, (value) => __awaiter(this, void 0, void 0, function* () {
                    const adbRemoteValue = value.split(':');
                    const adbHost = adbRemoteValue[0];
                    const adbPort = adbRemoteValue[1] || 5037;
                    const cloneAdb = originalADB.clone({
                        remoteAdbHost: adbHost,
                        adbPort,
                    });
                    deviceList.set(cloneAdb, yield cloneAdb.getConnectedDevices());
                    const remoteAdb = adbkit_1.default.createClient({
                        host: adbHost,
                        port: adbPort,
                    });
                    const remoteAdbTracking = this.createRemoteAdbTracker(remoteAdb, originalADB);
                    yield remoteAdbTracking();
                }));
            }
            return deviceList;
        });
    }
    onDeviceAdded(originalADB, device) {
        return __awaiter(this, void 0, void 0, function* () {
            const newDevice = { udid: device.id, state: device.type };
            logger_1.default.info(`Device ${newDevice.udid} was plugged. Detail: ${JSON.stringify(newDevice)}`);
            if (newDevice.state != 'offline') {
                logger_1.default.info(`Device ${newDevice.udid} was plugged`);
                this.initiateAbortControl(newDevice.udid);
                let bootCompleted = false;
                try {
                    yield this.waitBootComplete(originalADB, newDevice.udid);
                    bootCompleted = true;
                }
                catch (error) {
                    logger_1.default.info(`Device ${newDevice.udid} boot did not complete. Error: ${error}`);
                }
                if (!bootCompleted) {
                    logger_1.default.info(`Device ${newDevice.udid} boot did not complete in time. Ignoring`);
                    return;
                }
                this.cancelAbort(newDevice.udid);
                const trackedDevice = yield this.deviceInfo(newDevice, originalADB, this.pluginArgs, this.hostPort);
                if (!trackedDevice) {
                    logger_1.default.info(`Cannot get device info for ${newDevice.udid}. Skipping`);
                    return;
                }
                logger_1.default.info(`Adding device ${newDevice.udid} to list!`);
                if (this.pluginArgs.hub != undefined) {
                    logger_1.default.info(`Updating Hub with device ${newDevice.udid}`);
                    const nodeDevices = new NodeDevices_1.default(this.pluginArgs.hub);
                    yield nodeDevices.postDevicesToHub([trackedDevice], 'add');
                }
                // node also need a copy of devices, otherwise it cannot serve requests
                (0, device_service_1.addNewDevice)([trackedDevice], this.pluginArgs.bindHostOrIp);
            }
        });
    }
    createLocalAdbTracker(adbClient, originalADB) {
        const pluginArgs = this.pluginArgs;
        const adbTracker = () => __awaiter(this, void 0, void 0, function* () {
            try {
                const tracker = yield adbClient.trackDevices();
                tracker.on('add', (device) => __awaiter(this, void 0, void 0, function* () {
                    this.onDeviceAdded(originalADB, device);
                }));
                tracker.on('remove', (device) => __awaiter(this, void 0, void 0, function* () {
                    yield this.onDeviceRemoved(device, pluginArgs);
                }));
                tracker.on('change', (device) => __awaiter(this, void 0, void 0, function* () {
                    if (device.type === 'offline' || device.type === 'unauthorized') {
                        yield this.onDeviceRemoved(device, pluginArgs);
                    }
                    else {
                        this.onDeviceAdded(originalADB, device);
                    }
                }));
                tracker.on('end', () => logger_1.default.info('Tracking stopped'));
            }
            catch (err) {
                logger_1.default.error('Something went wrong:', err.stack);
            }
        });
        return adbTracker;
    }
    onDeviceRemoved(device, pluginArgs) {
        return __awaiter(this, void 0, void 0, function* () {
            const clonedDevice = {
                udid: device['id'],
                host: pluginArgs.bindHostOrIp,
                state: device.type,
            };
            if (pluginArgs.hub != undefined) {
                const nodeDevices = new NodeDevices_1.default(pluginArgs.hub);
                yield nodeDevices.postDevicesToHub([clonedDevice], 'remove');
            }
            // node also need a copy of devices, otherwise it cannot serve requests
            (0, device_service_1.removeDevice)([clonedDevice]);
            this.abort(clonedDevice.udid);
        });
    }
    createRemoteAdbTracker(adbClient, originalADB) {
        const pluginArgs = this.pluginArgs;
        const adbTracking = () => __awaiter(this, void 0, void 0, function* () {
            try {
                const tracker = yield adbClient.trackDevices();
                tracker.on('add', (device) => __awaiter(this, void 0, void 0, function* () {
                    this.onDeviceAdded(originalADB, device);
                }));
                tracker.on('remove', (device) => __awaiter(this, void 0, void 0, function* () {
                    this.onDeviceRemoved(device, pluginArgs);
                }));
                tracker.on('change', (device) => __awaiter(this, void 0, void 0, function* () {
                    if (device.type === 'offline' || device.type === 'unauthorized') {
                        logger_1.default.info(`Device ${device.id} is ${device.type}. Removing from list`);
                        yield this.onDeviceRemoved(device, pluginArgs);
                    }
                    else {
                        this.onDeviceAdded(originalADB, device);
                    }
                }));
                tracker.on('end', () => console.log('Tracking stopped'));
            }
            catch (err) {
                console.error('Something went wrong:', err.stack);
            }
        });
        return adbTracking;
    }
    getChromeVersion(adbInstance, udid, pluginArgs) {
        return __awaiter(this, void 0, void 0, function* () {
            if (pluginArgs.skipChromeDownload) {
                logger_1.default.warn('skipChromeDownload server arg is set; skipping Chromedriver installation.');
                logger_1.default.warn('Android web/hybrid testing will not be possible without Chromedriver.');
                return;
            }
            logger_1.default.debug('Getting package info for chrome');
            const chromeDriverManager = typedi_1.Container.get(ChromeDriverManager_1.default);
            let versionName = '';
            try {
                const stdout = yield (yield adbInstance).adbExec(['-s', udid, 'shell', 'dumpsys', 'package', 'com.android.chrome']);
                const versionNameMatch = new RegExp(/versionName=([\d+.]+)/).exec(stdout);
                if (versionNameMatch) {
                    versionName = versionNameMatch[1];
                    versionName = versionName.split('.')[0];
                    return yield chromeDriverManager.downloadChromeDriver(versionName);
                }
            }
            catch (err) {
                logger_1.default.warn(`Error '${err.message}' while dumping package info`);
            }
        });
    }
    downloadChromeDriver(version) {
        return __awaiter(this, void 0, void 0, function* () {
            const instance = yield ChromeDriverManager_1.default.getInstance();
            return yield instance.downloadChromeDriver(version);
        });
    }
    getDeviceVersion(adbInstance, udid) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.getDeviceProperty(adbInstance, udid, 'ro.build.version.release');
        });
    }
    getDeviceProperty(adbInstance, udid, prop) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield (yield adbInstance).adbExec(['-s', udid, 'shell', 'getprop', prop]);
            }
            catch (error) {
                logger_1.default.error(`Error while getting device property "${prop}" for ${udid}. Error: ${error}`);
            }
        });
    }
    isRealDevice(adbInstance, udid) {
        return __awaiter(this, void 0, void 0, function* () {
            const character = yield this.getDeviceProperty(adbInstance, udid, 'ro.build.characteristics');
            return character !== 'emulator';
        });
    }
    requireSdkRoot() {
        return __awaiter(this, void 0, void 0, function* () {
            const sdkRoot = (0, appium_adb_1.getSdkRootFromEnv)();
            const docMsg = 'Read https://developer.android.com/studio/command-line/variables for more details';
            if (lodash_1.default.isEmpty(sdkRoot)) {
                throw new Error(`Neither ANDROID_HOME nor ANDROID_SDK_ROOT environment variable was exported. ${docMsg}`);
            }
            if (!(yield support_1.fs.exists(sdkRoot))) {
                throw new Error(`The Android SDK root folder '${sdkRoot}' does not exist on the local file system. ${docMsg}`);
            }
            const stats = yield support_1.fs.stat(sdkRoot);
            if (!stats.isDirectory()) {
                throw new Error(`The Android SDK root '${sdkRoot}' must be a folder. ${docMsg}`);
            }
            return sdkRoot;
        });
    }
}
exports.default = AndroidDeviceManager;
