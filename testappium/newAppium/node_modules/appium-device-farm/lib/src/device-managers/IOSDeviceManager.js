"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_simctl_1 = __importDefault(require("node-simctl"));
const lodash_1 = require("lodash");
const appium_ios_device_1 = require("appium-ios-device");
const helpers_1 = require("../helpers");
const helpers_2 = require("../helpers");
const logger_1 = __importDefault(require("../logger"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const device_utils_1 = require("../device-utils");
const fs_extra_1 = __importDefault(require("fs-extra"));
const Devices_1 = __importDefault(require("./cloud/Devices"));
const NodeDevices_1 = __importDefault(require("./NodeDevices"));
const iOSTracker_1 = require("./iOSTracker");
const device_service_1 = require("../data-service/device-service");
class IOSDeviceManager {
    constructor(pluginArgs, hostPort) {
        this.pluginArgs = pluginArgs;
        this.hostPort = hostPort;
    }
    /**
     * Method to get all ios devices and simulators
     *
     * @returns {Promise<Array<IDevice>>}
     */
    getDevices(deviceTypes, existingDeviceDetails) {
        return __awaiter(this, void 0, void 0, function* () {
            if (deviceTypes.iosDeviceType === 'real') {
                return (0, lodash_1.flatten)(yield Promise.all([
                    this.getRealDevices(existingDeviceDetails, this.pluginArgs, this.hostPort),
                ]));
            }
            else if (deviceTypes.iosDeviceType === 'simulated') {
                const simulators = (0, lodash_1.flatten)(yield Promise.all([this.getSimulators()]));
                logger_1.default.debug(`Simulators: ${JSON.stringify(simulators)}`);
                return simulators;
            }
            else {
                // return both real and simulated devices
                return (0, lodash_1.flatten)(yield Promise.all([
                    this.getRealDevices(existingDeviceDetails, this.pluginArgs, this.hostPort),
                    this.getSimulators(),
                ]));
            }
        });
    }
    getConnectedDevices() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const devices = yield appium_ios_device_1.utilities.getConnectedDevices();
                return devices;
            }
            catch (error) {
                logger_1.default.error(error);
                return [];
            }
        });
    }
    getOSVersion(udid) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield appium_ios_device_1.utilities.getOSVersion(udid);
        });
    }
    getDeviceName(udid) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield appium_ios_device_1.utilities.getDeviceName(udid);
        });
    }
    getDevicePlatformName(name) {
        return name.toLowerCase().includes('tv') ? 'tvos' : 'ios';
    }
    /**
     * Method to get all ios real devices
     *
     * @returns {Promise<Array<IDevice>>}
     */
    getRealDevices(existingDeviceDetails, pluginArgs, hostPort) {
        return __awaiter(this, void 0, void 0, function* () {
            let deviceState = [];
            if (this.pluginArgs.cloud !== undefined) {
                const cloud = new Devices_1.default(this.pluginArgs.cloud, deviceState, 'ios');
                return yield cloud.getDevices();
            }
            else {
                deviceState = yield this.fetchLocalIOSDevices(existingDeviceDetails, pluginArgs, hostPort);
            }
            const returnDevices = deviceState.filter((device) => device.realDevice === true);
            return returnDevices;
        });
    }
    prepareDerivedDataPath(derivedDataPath, udid, realDevice) {
        function derivedPathExtracted(tmpPath, theDerivedDataPath) {
            if (theDerivedDataPath !== undefined) {
                fs_extra_1.default.copySync(theDerivedDataPath, tmpPath);
            }
            else {
                if (!fs_extra_1.default.existsSync(tmpPath)) {
                    logger_1.default.info(`DerivedDataPath for UDID ${udid} not set, so falling back to ${tmpPath}`);
                    logger_1.default.info(`WDA will be build once and will use WDA Runner from path ${tmpPath}, second test run will skip the build process`);
                    fs_extra_1.default.mkdirSync(tmpPath, { recursive: true });
                }
            }
        }
        if (derivedDataPath) {
            if (typeof derivedDataPath !== 'object')
                throw new Error('DerivedData Path should be able Object');
            const tmpPath = path_1.default.join(os_1.default.homedir(), `Library/Developer/Xcode/DerivedData/WebDriverAgent-${udid}`);
            if (realDevice) {
                derivedPathExtracted(tmpPath, derivedDataPath.device);
            }
            else {
                derivedPathExtracted(tmpPath, derivedDataPath.simulator);
            }
            return tmpPath;
        }
        else {
            return path_1.default.join(os_1.default.homedir(), `Library/Developer/Xcode/DerivedData/WebDriverAgent-${udid}`);
        }
    }
    fetchLocalIOSDevices(existingDeviceDetails, pluginArgs, hostPort) {
        return __awaiter(this, void 0, void 0, function* () {
            const devices = yield this.getConnectedDevices();
            const deviceState = [];
            yield (0, helpers_2.asyncForEach)(devices, (udid) => __awaiter(this, void 0, void 0, function* () {
                const existingDevice = existingDeviceDetails.find((device) => device.udid === udid);
                if (existingDevice) {
                    logger_1.default.info(`IOS Device details for ${udid} already available`);
                    deviceState.push(Object.assign(Object.assign({}, existingDevice), { busy: false, userBlocked: false }));
                }
                else {
                    const deviceInfo = yield this.getDeviceInfo(udid, pluginArgs, hostPort);
                    deviceState.push(deviceInfo);
                }
            }));
            // might as well track devices
            this.trackIOSDevices(pluginArgs);
            return deviceState;
        });
    }
    trackIOSDevices(pluginArgs) {
        return __awaiter(this, void 0, void 0, function* () {
            const goIosTracker = iOSTracker_1.GoIosTracker.getInstance();
            yield goIosTracker.start();
            goIosTracker.on('device-connected', (message) => __awaiter(this, void 0, void 0, function* () {
                const deviceAttached = [yield this.getDeviceInfo(message.id, pluginArgs, this.hostPort)];
                if (pluginArgs.hub !== undefined) {
                    logger_1.default.info(`Updating Hub with iOS device ${message.id}`);
                    const nodeDevices = new NodeDevices_1.default(pluginArgs.hub);
                    yield nodeDevices.postDevicesToHub(deviceAttached, 'add');
                }
                // add device to local list
                logger_1.default.info(`iOS device with udid ${message.id} plugged! updating device list...`);
                (0, device_service_1.addNewDevice)(deviceAttached, pluginArgs.bindHostOrIp);
            }));
            goIosTracker.on('device-removed', (message) => __awaiter(this, void 0, void 0, function* () {
                const deviceRemoved = [{ udid: message.id, host: pluginArgs.bindHostOrIp }];
                if (pluginArgs.hub !== undefined) {
                    logger_1.default.info(`iOS device with udid ${message.id} unplugged! updating hub device list...`);
                    const nodeDevices = new NodeDevices_1.default(pluginArgs.hub);
                    yield nodeDevices.postDevicesToHub(deviceRemoved, 'remove');
                }
                // remove device from local list
                logger_1.default.info(`iOS device with udid ${message.id} unplugged! updating device list...`);
                (0, device_service_1.removeDevice)(deviceRemoved);
            }));
        });
    }
    getDeviceInfo(udid, pluginArgs, hostPort) {
        return __awaiter(this, void 0, void 0, function* () {
            let host;
            if (pluginArgs.remoteMachineProxyIP) {
                host = pluginArgs.remoteMachineProxyIP;
            }
            else {
                host = `http://${pluginArgs.bindHostOrIp}:${hostPort}`;
            }
            const wdaLocalPort = yield (0, helpers_1.getFreePort)();
            const mjpegServerPort = yield (0, helpers_1.getFreePort)();
            const totalUtilizationTimeMilliSec = yield (0, device_utils_1.getUtilizationTime)(udid);
            const [sdk, name] = yield Promise.all([this.getOSVersion(udid), this.getDeviceName(udid)]);
            return Object.assign({
                wdaLocalPort,
                mjpegServerPort,
                udid,
                sdk,
                name,
                busy: false,
                realDevice: true,
                deviceType: 'real',
                platform: this.getDevicePlatformName(name),
                host,
                totalUtilizationTimeMilliSec: totalUtilizationTimeMilliSec,
                sessionStartTime: 0,
                derivedDataPath: this.prepareDerivedDataPath(pluginArgs.derivedDataPath, udid, true),
            });
        });
    }
    /**
     * Method to get all ios simulators
     *
     * @returns {Promise<Array<IDevice>>}
     */
    getSimulators() {
        return __awaiter(this, void 0, void 0, function* () {
            const simulators = yield this.fetchLocalSimulators();
            simulators.sort((a, b) => (a.state > b.state ? 1 : -1));
            // should not be here, but we need to update the hub with simulators
            /*if (this.pluginArgs.hub !== undefined) {
              log.info('Updating Hub with Simulators');
              const nodeDevices = new NodeDevices(this.pluginArgs.hub);
              await nodeDevices.postDevicesToHub(simulators, 'add');
            }*/
            return simulators;
        });
    }
    fetchLocalSimulators() {
        var _a, e_1, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.default.debug('Fetching local simulators');
            const returnedSimulators = [];
            const flattenValued = yield this.getLocalSims();
            let filteredSimulators = [];
            const localPluginArgs = this.pluginArgs;
            if (this.pluginArgs.simulators !== undefined) {
                filteredSimulators = flattenValued.filter((device) => localPluginArgs.simulators.some((simulator) => device.name === simulator.name && device.sdk === simulator.sdk));
            }
            //log.debug(`Filtered Simulators: ${JSON.stringify(filteredSimulators)}`);
            const buildSimulators = !(0, lodash_1.isEmpty)(filteredSimulators) ? filteredSimulators : flattenValued;
            try {
                //log.debug(`Build Simulators: ${JSON.stringify(buildSimulators)}`);
                for (var _d = true, buildSimulators_1 = __asyncValues(buildSimulators), buildSimulators_1_1; buildSimulators_1_1 = yield buildSimulators_1.next(), _a = buildSimulators_1_1.done, !_a; _d = true) {
                    _c = buildSimulators_1_1.value;
                    _d = false;
                    const device = _c;
                    const wdaLocalPort = yield (0, helpers_1.getFreePort)();
                    const mjpegServerPort = yield (0, helpers_1.getFreePort)();
                    const totalUtilizationTimeMilliSec = yield (0, device_utils_1.getUtilizationTime)(device.udid);
                    returnedSimulators.push(Object.assign(Object.assign(Object.assign({}, device), { wdaLocalPort,
                        mjpegServerPort, busy: false, realDevice: false, platform: this.getDevicePlatformName(device.name), deviceType: 'simulator', host: `http://${this.pluginArgs.bindHostOrIp}:${this.hostPort}`, totalUtilizationTimeMilliSec: totalUtilizationTimeMilliSec, sessionStartTime: 0, derivedDataPath: this.prepareDerivedDataPath(this.pluginArgs.derivedDataPath, device.udid, false) })));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = buildSimulators_1.return)) yield _b.call(buildSimulators_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return returnedSimulators;
        });
    }
    getLocalSims() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const simctl = new node_simctl_1.default();
                // list runtimes and log availability errors
                const list = yield simctl.list();
                const runtimes = list.runtimes;
                const unAavailableRuntimes = runtimes
                    .filter((runtime) => !runtime.isAvailable)
                    .map((runtime) => runtime.name);
                if (unAavailableRuntimes.length > 0) {
                    logger_1.default.error(`The following runtimes are not available: ${unAavailableRuntimes.join(', ')}`);
                }
                const iOSSimulators = (0, lodash_1.flatten)(Object.values(yield simctl.getDevices(null, 'iOS'))).length > 1;
                const tvSimulators = (0, lodash_1.flatten)(Object.values(yield simctl.getDevices(null, 'tvOS'))).length > 1;
                logger_1.default.debug(`iOS Simulators: ${iOSSimulators}`);
                logger_1.default.debug(`tvOS Simulators: ${tvSimulators}`);
                let iosSimulators = [];
                let tvosSimulators = [];
                if (iOSSimulators) {
                    iosSimulators = (0, lodash_1.flatten)(Object.values((yield simctl.getDevicesByParsing('iOS'))));
                }
                else {
                    logger_1.default.info('No iOS simulators found!');
                }
                if (tvSimulators) {
                    tvosSimulators = (0, lodash_1.flatten)(Object.values((yield simctl.getDevicesByParsing('tvOS'))));
                }
                else {
                    logger_1.default.info('No tvOS simulators found!');
                }
                return [...iosSimulators, ...tvosSimulators];
            }
            catch (error) {
                logger_1.default.error(error);
                return [];
            }
        });
    }
}
exports.default = IOSDeviceManager;
