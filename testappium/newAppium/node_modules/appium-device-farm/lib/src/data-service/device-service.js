"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.unblockDeviceMatchingFilter = exports.unblockDevice = exports.blockDevice = exports.userUnblockDevice = exports.userBlockDevice = exports.updateCmdExecutedTime = exports.updatedAllocatedDevice = exports.getDevice = exports.getDevices = exports.getAllDevices = exports.setSimulatorState = exports.addNewDevice = exports.removeDevice = void 0;
const db_1 = require("./db");
const logger_1 = __importDefault(require("../logger"));
const device_utils_1 = require("../device-utils");
const semver_1 = __importDefault(require("semver"));
function removeDevice(devices) {
    var _a, devices_1, devices_1_1;
    var _b, e_1, _c, _d;
    return __awaiter(this, void 0, void 0, function* () {
        try {
            for (_a = true, devices_1 = __asyncValues(devices); devices_1_1 = yield devices_1.next(), _b = devices_1_1.done, !_b; _a = true) {
                _d = devices_1_1.value;
                _a = false;
                const device = _d;
                logger_1.default.info(`Removing device ${device.udid} from host ${device.host} from device list.`);
                (yield db_1.ADTDatabase.DeviceModel)
                    .chain()
                    .find({ udid: device.udid, host: { $contains: device.host } })
                    .remove();
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (!_a && !_b && (_c = devices_1.return)) yield _c.call(devices_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    });
}
exports.removeDevice = removeDevice;
function addNewDevice(devices, host) {
    return __awaiter(this, void 0, void 0, function* () {
        /**
         * If the newly identified devices are not in the database, then add them to the database
         */
        const addedDevices = devices.map(function (device) {
            return __awaiter(this, void 0, void 0, function* () {
                // make sure all devices have host
                if (device.host === undefined && host !== undefined) {
                    device.host = host;
                }
                // make sure all devices have default values from IDevice
                device = Object.assign({
                    userBlocked: false,
                    offline: false,
                }, device);
                const isDeviceAlreadyPresent = (yield db_1.ADTDatabase.DeviceModel)
                    .chain()
                    .find({ udid: device.udid, host: device.host })
                    .data();
                if (isDeviceAlreadyPresent.length === 0) {
                    // @ts-ignore
                    delete device['$loki'];
                    // @ts-ignore
                    delete device['meta'];
                    try {
                        (yield db_1.ADTDatabase.DeviceModel).insert(Object.assign({}, device));
                        return device;
                    }
                    catch (error) {
                        logger_1.default.warn(`Unable to add device "${device.udid}" to database. Reason: ${error}`);
                    }
                }
                else {
                    logger_1.default.debug(`Device "${device.udid}" already exists in database`);
                }
            });
        });
        // nasty hack to remove undefined values from array while satisfying typescript checker
        const result = (yield Promise.all(addedDevices)).filter((device) => Boolean(device));
        logger_1.default.debug(`Added ${result.length} new devices to local database`);
        //log.debug(`Added devices: ${JSON.stringify(result)}`);
        //log.debug(
        //  `All devices: ${JSON.stringify((await ADTDatabase.DeviceModel).chain().find().data())}`,
        //);
        return result;
    });
}
exports.addNewDevice = addNewDevice;
function setSimulatorState(devices) {
    var _a, devices_2, devices_2_1;
    var _b, e_2, _c, _d;
    return __awaiter(this, void 0, void 0, function* () {
        try {
            /**
             * Update the Latest Simulator state in DB
             */
            for (_a = true, devices_2 = __asyncValues(devices); devices_2_1 = yield devices_2.next(), _b = devices_2_1.done, !_b; _a = true) {
                _d = devices_2_1.value;
                _a = false;
                const device = _d;
                const allDevices = (yield db_1.ADTDatabase.DeviceModel).chain().find().data();
                if (allDevices.length != 0 && device.deviceType === 'simulator') {
                    const { state } = allDevices.find((d) => d.udid === device.udid);
                    if (state !== device.state) {
                        logger_1.default.info(`Updating Simulator status from ${state} to ${device.state} for device ${device.udid}`);
                        (yield db_1.ADTDatabase.DeviceModel)
                            .chain()
                            .find({ udid: device.udid })
                            .update(function (d) {
                            d.state = device.state;
                        });
                    }
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (!_a && !_b && (_c = devices_2.return)) yield _c.call(devices_2);
            }
            finally { if (e_2) throw e_2.error; }
        }
    });
}
exports.setSimulatorState = setSimulatorState;
function getAllDevices() {
    return __awaiter(this, void 0, void 0, function* () {
        return (yield db_1.ADTDatabase.DeviceModel).chain().find().data();
    });
}
exports.getAllDevices = getAllDevices;
/**
 * Find devices matching filter options
 * @param filterOptions IDeviceFilterOptions
 * @returns IDevice[]
 */
function getDevices(filterOptions) {
    return __awaiter(this, void 0, void 0, function* () {
        // host, userBlocked must not be undefined
        const basicFilter = { host: { $ne: undefined }, userBlocked: { $ne: undefined } };
        const deviceModel = yield db_1.ADTDatabase.DeviceModel;
        let results = deviceModel.chain().find(basicFilter);
        const filter = {};
        const filterOptionKeys = Object.keys(filterOptions);
        filterOptionKeys
            .filter((key) => filterOptions[key] !== undefined)
            .forEach((key) => {
            switch (key) {
                case 'platform':
                    filter.platform = filterOptions.platform;
                    break;
                case 'platformVersion':
                    logger_1.default.debug(`platformVersion: ${filterOptions.platformVersion}`);
                    const coercedPlatformVersion = semver_1.default.coerce(filterOptions.platformVersion);
                    results = results.where(function (obj) {
                        const coercedSDK = semver_1.default.coerce(obj.sdk);
                        // log.debug(`coerced obj SDK: ${coercedSDK}`);
                        if (coercedSDK && coercedPlatformVersion) {
                            /*log.debug(
                              `coerced obj SDK: ${coercedSDK} == coercedPlatformVersion: ${coercedPlatformVersion}`,
                            );*/
                            return semver_1.default.eq(coercedSDK, coercedPlatformVersion);
                        }
                        return false;
                    });
                    break;
                case 'name':
                    // only is name is not empty nor undefined
                    if (filterOptions.name !== undefined && filterOptions.name.trim() !== '')
                        filter.name = { $contains: filterOptions.name.trim() };
                    else
                        filter.name = { $ne: undefined };
                    break;
                case 'busy':
                    filter.busy = filterOptions.busy;
                    break;
                case 'offline':
                    filter.offline = filterOptions.offline;
                    break;
                case 'userBlocked':
                    filter.userBlocked = filterOptions.userBlocked;
                    break;
                case 'udid':
                    // udid is an array
                    if (filterOptions.udid.length > 0)
                        filter.udid = { $contains: filterOptions.udid };
                    break;
                case 'deviceType':
                    filter.deviceType = filterOptions.deviceType;
                    break;
                case 'session_id':
                    filter.session_id = filterOptions.session_id;
                    break;
                case 'minSDK':
                    if (semver_1.default.coerce(filterOptions.minSDK)) {
                        // log.debug(`minSDK: ${filterOptions.minSDK}`);
                        const coercedMinSDK = semver_1.default.coerce(filterOptions.minSDK);
                        results = results.where(function (obj) {
                            const coercedSDK = semver_1.default.coerce(obj.sdk);
                            if (coercedSDK && coercedMinSDK) {
                                // log.debug(`coerced obj SDK: ${coercedSDK} >= coercedMinSDK: ${coercedMinSDK}`);
                                return semver_1.default.gte(coercedSDK, coercedMinSDK);
                            }
                            return false;
                        });
                    }
                    break;
                case 'maxSDK':
                    if (semver_1.default.coerce(filterOptions.maxSDK)) {
                        // log.debug(`maxSDK: ${filterOptions.maxSDK}`);
                        const coercedMaxSDK = semver_1.default.coerce(filterOptions.maxSDK);
                        results = results.where(function (obj) {
                            const coercedSDK = semver_1.default.coerce(obj.sdk);
                            // log.debug(`coerced obj SDK: ${coercedSDK}`);
                            if (coercedSDK && coercedMaxSDK) {
                                return semver_1.default.lte(coercedSDK, coercedMaxSDK);
                            }
                            return false;
                        });
                    }
                    break;
                default:
                    // do not remove this line as it will help us to know if we have missed any filter options
                    const exhaustiveCheck = key;
                    break;
            }
        });
        if (filterOptions.deviceType === 'simulator') {
            filter.state = 'Booted';
        }
        const matchingDevices = results.find(filter).data();
        // use the following debugging tools to debug this function
        /*
        log.debug(`basic filter: ${JSON.stringify(basicFilter)}`);
        log.debug(`all devices: ${JSON.stringify(deviceModel.chain().find().data())}`);
        log.debug(`basic filter applied devices: ${JSON.stringify(deviceModel.chain().find(basicFilter).data())}`);
        log.debug(`filter: ${JSON.stringify(filter)}`);
        log.debug(`results: ${JSON.stringify(matchingDevices)}`);
        */
        return matchingDevices;
    });
}
exports.getDevices = getDevices;
/**
 * Find device matching the filter options
 * @param filterOptions IDeviceFilterOptions
 * @returns IDevice | undefined
 */
function getDevice(filterOptions) {
    return __awaiter(this, void 0, void 0, function* () {
        const devices = yield getDevices(filterOptions);
        // log.debug(`getDevice devices: ${JSON.stringify(devices)}`);
        if (devices.length === 0) {
            return undefined;
        }
        else {
            return devices[0];
        }
    });
}
exports.getDevice = getDevice;
function updatedAllocatedDevice(device, updateData) {
    return __awaiter(this, void 0, void 0, function* () {
        logger_1.default.info(`Updating allocated device: "${JSON.stringify(device)}"`);
        (yield db_1.ADTDatabase.DeviceModel)
            .chain()
            .find({ udid: device.udid, host: device.host })
            .update(function (device) {
            Object.assign(device, Object.assign({}, updateData));
        });
    });
}
exports.updatedAllocatedDevice = updatedAllocatedDevice;
function updateCmdExecutedTime(sessionId) {
    return __awaiter(this, void 0, void 0, function* () {
        (yield db_1.ADTDatabase.DeviceModel)
            .chain()
            .find({ session_id: sessionId })
            .update(function (device) {
            logger_1.default.debug(`Updating lastCmdExecutedAt for device ${device.udid} in session ${sessionId}`);
            device.lastCmdExecutedAt = new Date().getTime();
        });
    });
}
exports.updateCmdExecutedTime = updateCmdExecutedTime;
/**
 * Apply user blocking device. Device busy status will not be affected.
 * @param udid string
 * @param host string
 */
function userBlockDevice(udid, host) {
    return __awaiter(this, void 0, void 0, function* () {
        // we are requiring host as emulator/simulator name may be the same for different hosts
        (yield db_1.ADTDatabase.DeviceModel)
            .chain()
            .find({ udid: udid, host: host })
            .update(function (device) {
            device.userBlocked = true;
        });
    });
}
exports.userBlockDevice = userBlockDevice;
function userUnblockDevice(udid, host) {
    return __awaiter(this, void 0, void 0, function* () {
        // we are requiring host as emulator/simulator name may be the same for different hosts
        (yield db_1.ADTDatabase.DeviceModel)
            .chain()
            .find({ udid: udid, host: host })
            .update(function (device) {
            device.userBlocked = false;
        });
    });
}
exports.userUnblockDevice = userUnblockDevice;
/**
 * Block device from being allocated to a session. Device busy status will be set to true.
 * @param udid
 * @param host
 */
function blockDevice(udid, host) {
    return __awaiter(this, void 0, void 0, function* () {
        // we are requiring host as emulator/simulator name may be the same for different hosts
        (yield db_1.ADTDatabase.DeviceModel)
            .chain()
            .find({ udid: udid, host: host })
            .update(function (device) {
            device.busy = true;
            device.lastCmdExecutedAt = undefined;
        });
    });
}
exports.blockDevice = blockDevice;
function unblockDevice(udid, host) {
    return __awaiter(this, void 0, void 0, function* () {
        unblockDeviceMatchingFilter({ udid, host });
    });
}
exports.unblockDevice = unblockDevice;
function unblockDeviceMatchingFilter(filter) {
    return __awaiter(this, void 0, void 0, function* () {
        const deviceModel = yield db_1.ADTDatabase.DeviceModel;
        let devices;
        if (Object.keys(filter).length === 0) {
            devices = deviceModel.chain().find().data();
        }
        else {
            devices = deviceModel.chain().find(filter).data();
        }
        if (devices !== undefined) {
            // log.debug(`Found ${devices.length} devices to unblock with filter ${JSON.stringify(filter)}`);
            yield Promise.all(devices.map((device) => __awaiter(this, void 0, void 0, function* () {
                const sessionStart = device.sessionStartTime;
                const currentTime = new Date().getTime();
                let utilization = currentTime - sessionStart;
                // no session time recorded means device was never used
                if (sessionStart === 0) {
                    utilization = 0;
                }
                const totalUtilization = device.totalUtilizationTimeMilliSec + utilization;
                yield (0, device_utils_1.setUtilizationTime)(device.udid, totalUtilization);
                deviceModel.findAndUpdate({ udid: device.udid, host: device.host }, function (device) {
                    // log.debug(`Unblocking device ${device.udid} from host ${device.host}`);
                    device.session_id = undefined;
                    device.busy = false;
                    device.lastCmdExecutedAt = undefined;
                    device.sessionStartTime = 0;
                    device.totalUtilizationTimeMilliSec = totalUtilization;
                    device.newCommandTimeout = undefined;
                });
                logger_1.default.debug(`Unblocked device ${device.udid} from host ${device.host}`);
            }))).catch((error) => {
                logger_1.default.error(`Unable to unblock device. Reason: ${error}`);
            });
        }
        else {
            logger_1.default.warn(`Unable to find device to unblock with filter ${JSON.stringify(filter)}`);
        }
    });
}
exports.unblockDeviceMatchingFilter = unblockDeviceMatchingFilter;
