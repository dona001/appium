"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DevicePlugin = void 0;
/* eslint-disable no-prototype-builtins */
require("reflect-metadata");
const index_1 = __importDefault(require("./commands/index"));
const base_plugin_1 = __importDefault(require("@appium/base-plugin"));
const app_1 = require("./app");
const async_lock_1 = __importDefault(require("async-lock"));
const device_service_1 = require("./data-service/device-service");
const pending_sessions_service_1 = require("./data-service/pending-sessions-service");
const device_utils_1 = require("./device-utils");
const device_managers_1 = require("./device-managers");
const typedi_1 = require("typedi");
const logger_1 = __importDefault(require("./logger"));
const uuid_1 = require("uuid");
const axios_1 = __importStar(require("axios"));
const https_proxy_agent_1 = require("https-proxy-agent");
const http_proxy_agent_1 = require("http-proxy-agent");
const helpers_1 = require("./helpers");
const wd_command_proxy_1 = require("./wd-command-proxy");
const ChromeDriverManager_1 = __importDefault(require("./device-managers/ChromeDriverManager"));
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
const pluginArgs_1 = require("./data-service/pluginArgs");
const Cloud_1 = __importDefault(require("./enums/Cloud"));
const ip_1 = __importDefault(require("ip"));
const appium_adb_1 = require("appium-adb");
const IPluginArgs_1 = require("./interfaces/IPluginArgs");
const NodeDevices_1 = __importDefault(require("./device-managers/NodeDevices"));
const commandsQueueGuard = new async_lock_1.default();
const DEVICE_MANAGER_LOCK_NAME = 'DeviceManager';
let platform;
let androidDeviceType;
let iosDeviceType;
let hasEmulators;
let proxy;
class DevicePlugin extends base_plugin_1.default {
    constructor(pluginName, cliArgs) {
        super(pluginName, cliArgs);
        this.pluginArgs = Object.assign({}, IPluginArgs_1.DefaultPluginArgs);
        // here, CLI Args are already pluginArgs. Different case for updateServer
        logger_1.default.debug(`ðŸ“± Plugin Args: ${JSON.stringify(cliArgs)}`);
        // plugin args will assign undefined value as well for bindHostOrIp
        this.pluginArgs = Object.assign({}, IPluginArgs_1.DefaultPluginArgs, this.cliArgs);
        // not pretty but will do for now
        if (this.pluginArgs.bindHostOrIp === undefined) {
            this.pluginArgs.bindHostOrIp = ip_1.default.address();
        }
    }
    onUnexpectedShutdown(driver, cause) {
        const deviceFilter = {
            session_id: driver.sessionId ? driver.sessionId : undefined,
            udid: driver.caps && driver.caps.udid ? driver.caps.udid : undefined,
        };
        if (this.pluginArgs.hub !== undefined) {
            // send unblock request to hub. Should we unblock the whole devices from this node?
            new NodeDevices_1.default(this.pluginArgs.hub).unblockDevice(deviceFilter);
        }
        else {
            (0, device_service_1.unblockDeviceMatchingFilter)(deviceFilter);
        }
        logger_1.default.info(`Unblocking device mapped with filter ${JSON.stringify(deviceFilter)} onUnexpectedShutdown from server`);
    }
    static updateServer(expressApp, httpServer, cliArgs) {
        return __awaiter(this, void 0, void 0, function* () {
            // cliArgs are here is not pluginArgs yet as it contains the whole CLI argument for Appium! Different case for our plugin constructor
            logger_1.default.debug(`ðŸ“± Update server with CLI Args: ${JSON.stringify(cliArgs)}`);
            const pluginConfigs = cliArgs.plugin;
            let pluginArgs;
            if (pluginConfigs['device-farm'] !== undefined) {
                pluginArgs = Object.assign({}, IPluginArgs_1.DefaultPluginArgs, pluginConfigs['device-farm']);
            }
            else {
                pluginArgs = Object.assign({}, IPluginArgs_1.DefaultPluginArgs);
            }
            // I'm transferring the CLI Args to pluginArgs here.
            DevicePlugin.nodeBasePath = cliArgs.basePath;
            if (pluginArgs.bindHostOrIp === undefined) {
                pluginArgs.bindHostOrIp = ip_1.default.address();
            }
            logger_1.default.debug(`ðŸ“± Update server with Plugin Args: ${JSON.stringify(pluginArgs)}`);
            platform = pluginArgs.platform;
            androidDeviceType = pluginArgs.androidDeviceType;
            iosDeviceType = pluginArgs.iosDeviceType;
            if (pluginArgs.proxy !== undefined) {
                logger_1.default.info(`Adding proxy for axios: ${JSON.stringify(pluginArgs.proxy)}`);
                proxy = pluginArgs.proxy;
            }
            else {
                logger_1.default.info('proxy is not required for axios');
            }
            hasEmulators = pluginArgs.emulators && pluginArgs.emulators.length > 0;
            expressApp.use('/device-farm', app_1.router);
            (0, wd_command_proxy_1.registerProxyMiddlware)(expressApp);
            if (!platform)
                throw new Error('ðŸ”´ ðŸ”´ ðŸ”´ Specify --plugin-device-farm-platform from CLI as android,iOS or both or use appium server config. Please refer ðŸ”— https://github.com/appium/appium/blob/master/packages/appium/docs/en/guides/config.md ðŸ”´ ðŸ”´ ðŸ”´');
            if (hasEmulators && pluginArgs.platform.toLowerCase() === 'android') {
                logger_1.default.info('Emulators will be booted!!');
                const adb = yield appium_adb_1.ADB.createADB({});
                const array = pluginArgs.emulators || [];
                const promiseArray = array.map((arr) => __awaiter(this, void 0, void 0, function* () {
                    yield Promise.all([yield adb.launchAVD(arr.avdName, arr)]);
                }));
                yield Promise.all(promiseArray);
            }
            const chromeDriverManager = pluginArgs.skipChromeDownload === false ? yield ChromeDriverManager_1.default.getInstance() : undefined;
            iosDeviceType = DevicePlugin.setIncludeSimulatorState(pluginArgs, iosDeviceType);
            const deviceTypes = { androidDeviceType, iosDeviceType };
            const deviceManager = new device_managers_1.DeviceFarmManager(platform, deviceTypes, cliArgs.port, pluginArgs);
            typedi_1.Container.set(device_managers_1.DeviceFarmManager, deviceManager);
            if (chromeDriverManager)
                typedi_1.Container.set(ChromeDriverManager_1.default, chromeDriverManager);
            yield (0, pluginArgs_1.addCLIArgs)(cliArgs);
            yield (0, device_utils_1.initializeStorage)();
            logger_1.default.info(`ðŸ“£ðŸ“£ðŸ“£ Device Farm Plugin will be served at ðŸ”— http://${pluginArgs.bindHostOrIp}:${cliArgs.port}/device-farm`);
            const hubArgument = pluginArgs.hub;
            if (hubArgument !== undefined) {
                logger_1.default.info(`ðŸ“£ðŸ“£ðŸ“£ I'm a node and my hub is ${hubArgument}`);
                // hub may have been restarted, so let's send device list regularly
                yield (0, device_utils_1.setupCronUpdateDeviceList)(pluginArgs.bindHostOrIp, hubArgument, pluginArgs.sendNodeDevicesToHubIntervalMs);
            }
            else {
                logger_1.default.info(`ðŸ“£ðŸ“£ðŸ“£ I'm a hub and I'm listening on ${pluginArgs.bindHostOrIp}:${cliArgs.port}`);
            }
            // check for stale nodes
            yield (0, device_utils_1.setupCronCheckStaleDevices)(pluginArgs.checkStaleDevicesIntervalMs, pluginArgs.bindHostOrIp);
            // and release blocked devices
            yield (0, device_utils_1.setupCronReleaseBlockedDevices)(pluginArgs.checkBlockedDevicesIntervalMs, pluginArgs.newCommandTimeoutSec);
            // and clean up pending sessions
            yield (0, device_utils_1.setupCronCleanPendingSessions)(pluginArgs.checkBlockedDevicesIntervalMs, pluginArgs.deviceAvailabilityTimeoutMs + 10000);
            const devicesUpdates = yield (0, device_utils_1.updateDeviceList)(pluginArgs.bindHostOrIp, hubArgument);
            if ((0, device_utils_1.isIOS)(pluginArgs) && (0, device_utils_1.deviceType)(pluginArgs, 'simulated')) {
                yield (0, device_service_1.setSimulatorState)(devicesUpdates);
                yield (0, device_utils_1.refreshSimulatorState)(pluginArgs, cliArgs.port);
            }
            // unblock all devices on node/hub restart
            yield (0, device_service_1.unblockDeviceMatchingFilter)({});
            // remove stale devices
            yield (0, device_utils_1.removeStaleDevices)(pluginArgs.bindHostOrIp);
        });
    }
    static setIncludeSimulatorState(pluginArgs, deviceTypes) {
        if ((0, helpers_1.isCloud)(pluginArgs)) {
            deviceTypes = 'real';
            logger_1.default.info('â„¹ï¸ Skipping Simulators as per the configuration â„¹ï¸');
        }
        return deviceTypes;
    }
    static waitForRemoteDeviceFarmToBeRunning(host) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, helpers_1.spinWith)(`Waiting for device farm server ${host} to be up and running\n`, () => __awaiter(this, void 0, void 0, function* () {
                return yield (0, helpers_1.isDeviceFarmRunning)(host);
            }), (msg) => {
                throw new Error(`Failed: ${msg}`);
            });
        });
    }
    createSession(next, driver, jwpDesCaps, jwpReqCaps, caps) {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.default.debug(`ðŸ“± pluginArgs: ${JSON.stringify(this.pluginArgs)}`);
            logger_1.default.debug(`Receiving session request at host: ${this.pluginArgs.bindHostOrIp}`);
            const pendingSessionId = (0, uuid_1.v4)();
            logger_1.default.debug(`ðŸ“± Creating temporary session capability_id: ${pendingSessionId}`);
            const { alwaysMatch: requiredCaps = {}, // If 'requiredCaps' is undefined, set it to an empty JSON object (#2.1)
            firstMatch: allFirstMatchCaps = [{}], // If 'firstMatch' is undefined set it to a singleton list with one empty object (#3.1)
             } = caps;
            (0, helpers_1.stripAppiumPrefixes)(requiredCaps);
            (0, helpers_1.stripAppiumPrefixes)(allFirstMatchCaps);
            yield (0, pending_sessions_service_1.addNewPendingSession)(Object.assign(Object.assign({}, Object.assign({}, caps.firstMatch[0], caps.alwaysMatch)), { capability_id: pendingSessionId, 
                // mark the insertion date
                createdAt: new Date().getTime() }));
            /**
             *  Wait untill a free device is available for the given capabilities
             */
            const device = yield commandsQueueGuard.acquire(DEVICE_MANAGER_LOCK_NAME, () => __awaiter(this, void 0, void 0, function* () {
                //await refreshDeviceList();
                try {
                    return yield (0, device_utils_1.allocateDeviceForSession)(caps, this.pluginArgs.deviceAvailabilityTimeoutMs, this.pluginArgs.deviceAvailabilityQueryIntervalMs, this.pluginArgs);
                }
                catch (err) {
                    yield (0, pending_sessions_service_1.removePendingSession)(pendingSessionId);
                    throw err;
                }
            }));
            let session;
            logger_1.default.debug(`device.host: ${device.host} and pluginArgs.bindHostOrIp: ${this.pluginArgs.bindHostOrIp}`);
            // if device is not on the same node, forward the session request. Unless hub is not defined then create session on the same node
            if (this.pluginArgs.hub == undefined &&
                device.host !== undefined &&
                !device.host.includes(this.pluginArgs.bindHostOrIp)) {
                logger_1.default.debug(`ðŸ“± Forwarding session request to ${device.host}`);
                session = yield this.forwardSessionRequest(device, caps);
            }
            else {
                logger_1.default.debug(`ðŸ“± Creating session on the same node`);
                session = yield next();
            }
            // non-forwarded session can also be an error
            logger_1.default.debug('ðŸ“± Session response: ', JSON.stringify(session));
            logger_1.default.debug(`ðŸ“± Removing pending session with capability_id: ${pendingSessionId}`);
            yield (0, pending_sessions_service_1.removePendingSession)(pendingSessionId);
            // This is coming from the forwarded session
            if (session instanceof Error || session.hasOwnProperty('error')) {
                yield (0, device_service_1.unblockDevice)(device.udid, device.host);
                logger_1.default.info(`ðŸ“± Device UDID ${device.udid} unblocked. Reason: Failed to create session`);
                this.throwProperError(session, device.host);
            }
            else if (session.error !== undefined) {
            }
            else {
                // @ts-ignore
                const sessionId = session.value[0];
                logger_1.default.info(`ðŸ“± Device UDID ${device.udid} blocked for session ${sessionId}`);
                yield (0, device_service_1.updatedAllocatedDevice)(device, {
                    busy: true,
                    session_id: sessionId,
                    lastCmdExecutedAt: new Date().getTime(),
                    sessionStartTime: new Date().getTime(),
                });
                if (device.host !== undefined && !device.host.includes(this.pluginArgs.bindHostOrIp)) {
                    (0, wd_command_proxy_1.addProxyHandler)(sessionId, device.host);
                }
                logger_1.default.info(`ðŸ“± Updating Device ${device.udid} with session ID ${sessionId}`);
            }
            return session;
        });
    }
    throwProperError(session, host) {
        if (session instanceof Error) {
            throw session;
        }
        else if (session.hasOwnProperty('error')) {
            const errorMessage = session.error;
            if (errorMessage) {
                throw new Error(errorMessage);
            }
            else {
                throw new Error(`Unknown error while creating session. Better look at appium log on the node: ${host}`);
            }
        }
        else {
            throw new Error(`Unknown error while creating session. Better look at appium log on the node: ${host}`);
        }
    }
    forwardSessionRequest(device, caps) {
        return __awaiter(this, void 0, void 0, function* () {
            const remoteUrl = (0, helpers_1.nodeUrl)(device);
            let capabilitiesToCreateSession = { capabilities: caps };
            if (device.hasOwnProperty('cloud') && device.cloud.toLowerCase() === Cloud_1.default.LAMBDATEST) {
                capabilitiesToCreateSession = Object.assign(capabilitiesToCreateSession, {
                    desiredCapabilities: capabilitiesToCreateSession.capabilities.alwaysMatch,
                });
            }
            let createdSession;
            logger_1.default.info(`Creating session with desiredCapabilities: "${JSON.stringify(capabilitiesToCreateSession)}"`);
            const config = {
                method: 'post',
                url: remoteUrl,
                headers: {
                    'Content-Type': 'application/json',
                },
                data: capabilitiesToCreateSession,
            };
            //log.info(`Add proxy to axios config only if it is set: ${JSON.stringify(proxy)}`);
            if (proxy != undefined) {
                logger_1.default.info(`Added proxy to axios config: ${JSON.stringify(proxy)}`);
                config.httpsAgent = new https_proxy_agent_1.HttpsProxyAgent(proxy);
                config.httpAgent = new http_proxy_agent_1.HttpProxyAgent(proxy);
                config.proxy = false;
            }
            logger_1.default.info(`With axios config: "${JSON.stringify(config)}"`);
            createdSession = yield this.invokeSessionRequest(config);
            if (createdSession instanceof Error) {
                return createdSession;
            }
            else {
                return {
                    protocol: 'W3C',
                    value: [createdSession.value.sessionId, createdSession.value.capabilities, 'W3C'],
                };
            }
        });
    }
    invokeSessionRequest(config) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let sessionDetails;
            let errorMessage;
            try {
                const response = yield (0, axios_1.default)(config);
                logger_1.default.debug('remote node response', JSON.stringify(response.data));
                // Appium endpoint returns session details w3c format: https://github.com/jlipps/simple-wd-spec?tab=readme-ov-file#new-session
                sessionDetails = response.data;
                // check if we have error in response by checking sessionDetails.value type
                if ('error' in sessionDetails.value) {
                    logger_1.default.error(`Error while creating session: ${sessionDetails.value.error}`);
                    errorMessage = sessionDetails.value.error;
                }
            }
            catch (error) {
                logger_1.default.debug(`Received error from remote node: ${JSON.stringify(error)}`);
                if (error instanceof axios_1.AxiosError) {
                    errorMessage = JSON.stringify((_a = error.response) === null || _a === void 0 ? void 0 : _a.data);
                }
                else {
                    errorMessage = error;
                }
            }
            // @ts-ignore
            if (errorMessage) {
                logger_1.default.error(`Error while creating session: ${errorMessage}`);
                return new Error(errorMessage);
            }
            else {
                // @ts-ignore
                logger_1.default.debug(`ðŸ“± Session received with details: ${JSON.stringify(sessionDetails)}`);
                // @ts-ignore
                return sessionDetails;
            }
        });
    }
    deleteSession(next, driver, sessionId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, device_service_1.unblockDeviceMatchingFilter)({ session_id: sessionId });
            logger_1.default.info(`ðŸ“± Unblocking the device that is blocked for session ${sessionId}`);
            return yield next();
        });
    }
}
exports.DevicePlugin = DevicePlugin;
DevicePlugin.nodeBasePath = '';
Object.assign(DevicePlugin.prototype, index_1.default);
